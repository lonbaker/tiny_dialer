#!/usr/bin/env ruby

require_relative '../lib/tiny_dialer'
require TinyDialer::MODEL_ROOT/:init
require TinyDialer::LIBROOT/:tiny_dialer/:hopper
require TinyDialer::LIBROOT/:tiny_dialer/:dialer
require "eventmachine"
require "fsr"
require "fsr/command_socket"

class TinyDialer::DialManager
  attr_reader :hopper, :host, :pass
  def initialize(o = {:dialers => 1, :host => '127.0.0.1', :pass => 'ClueCon'})
    @host         = o[:host] || '127.0.0.1'
    @pass         = o[:pass] || 'ClueCon'
    @proxy_server = o[:proxy_server] || '127.0.0.1'

    TinyDialer::Log.info "DialManager initialized with #{max_dialers} dialers"

    @hopper = TinyDialer::Hopper.create(:max_size => 100)
  end

  def current_dialers
    sock = FSR::CommandSocket.new(:server => @host, :pass => @pass)
    sock.channels.run.select{|ch| ch.direction != "inbound" }
  end

  def max_dialers
    TinyDialer.db[:dialer_pool].first[:dialer_max]
  end

  def need_dialers
    max_dialers - current_dialers.size
  end

  def dial(timer)
    dialer = TinyDialer::Dialer.new(
      host: @host,
      pass: @pass,
      hopper: @hopper,
      proxy_server: @proxy_server
    )
    dialer.dial(timer)
  end
end

::EM.run do
  opts = {}
  opts[:proxy_server] = ENV["TINY_DIALER_PROXY_SERVER"]

  FSR.load_all_commands
  dial_manager = TinyDialer::DialManager.new(opts)

  timer = EM.add_periodic_timer(0.05){
    EM.defer do
      dial_manager.dial(timer)
    end
  }
end
